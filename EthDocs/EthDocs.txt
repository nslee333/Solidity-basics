
Introduction:

This is going to be my notes and code from going through the Solidity/
Ethereum Documentation.

The plan is to write notes and make sure I understand the material, 
and develop my knowlege as a developer.

//--------------------------------------------------------------------

https://ethereum.org/en/developers/docs/intro-to-ethereum/

Intro to Ethereum.

What is a blockchain?

A Blockchain is a public database that is updated and shared across
many computers in a network.

"Block" refers to data and state being stored in consecutive groups
known as blocks.

If you send Eth to someone else, the transaction data needs to be 
added to a block to be successful.

"Chain" refers to the fact that each block cryptographically 
references its parent. In other words, the blocks are chained together.
The data in a block cannot change without changing all subsequent 
blocks, which would require the consesus of the entire network.

Every computer in the network must agree upon each new Block and the 
chain as a whole. These computers are known as 'Nodes'. Nodes
ensure everyone interacting with the Blockchain has the same data.
To acomplish this distributed agreement, blockchains need a consensus
mechanism.

Ethereum currently uses a proof-of-work consensus mechanism. This 
means that anyone who wants to add new blocks to the chain must
solve a difficult puzzle that requires alot of computing power.

Solving the puzzle 'proves' that you've done the 'work' by using 
computational resources. Doing this is known as mining. Mining is 
typically brute force trial and error, but successfully adding A
block is rewarded in Eth.

New blocks are broadcast to the nodes in the network, checked
and verified, thus updating the state of the blockchain for everyone.

So to summarize, when you send Eth to someone, the transaction must
be mined and included in a new block. The updated state is then shared
with the entire network.

https://www.youtube.com/watch?v=zcX7OJ-L8XQ

//---------------------------

https://www.youtube.com/watch?v=_160oMzblY8&t=30s

SHA256 Hash

A hash looks like a random string of numbers and letters, but 
essentially what it is, is a a digital fingerprint of some digital 
data.

// Entering Personal Note.

// I'm entering my own notes here on SHA256.

SHA256 stands for Secure Hashing Algorithim. 

It is used by IPFS as its main cryptographic hash algorithim, that is
used essentially as a "fingerprint" of the data, or barcode.

SHA256 is determanistic, meaning, that the data that is input into it
it will always get the same hash everytime. 

E.g. I typed in my name 'nathan' into this generator:

https://passwordsgenerator.net/sha256-hash-generator/

and it spit out D2653FF---------------------.

Everytime I go into it, and type the same "nathan" it will always
return the same hash D2653ff.

// Exit Personal Note.

So we've explained how a SHA256 Hash works.

When we use the SHA, we have an input and an output, the data and the
hash.

A block expands the data to three sections:

1. The Block Number.
2. The Nonce.
3. The Data itself.

The Hash includes all of the above data, and it begins with four zeros.

0000xxxxxxxxxxxx

We can gather from this information, is that the four zeros stand for
a 'signed' or valid block.

Whenever we have an "unsigned" block it dosen't have the four zeros.

This is where a nonce comes in.

// Begin personal note:

In the video I'm following, he dosen't explain the concept of a nonce
well, so I found another video that explains it fairly well.

https://www.youtube.com/watch?v=EOgpr73-pgc

Notes for the video:

- The easiest way to explain a Nonce in cyptography is a 
CAPTCHA. 

(CAPTCHA stands for Completely Automated Public Turing Test to tell
Computers and Humans apart, is a type of challenge-response Test used
in computing to determine whether or not the user is human.)

- A nonce is a randomized set of digits (Typically numbers) that is 
used to verify the data that has been submitted, has only been 
submitted once.

- Let's say for example, theres a thing called a replay attack,
a replay attack is when, lets say you're submitting
Identity verification (authentication), like username and password.

In a replay attack is when a third party finds and records
your id and password, and then uses it to gain access to your account
later for what ever purpose, this is a replay attack.

This is why we have CAPTCHA, we use this to stop these type of attacks.

A nonce in Cryptography is an authentication tool that makes sure
that a block that has been submitted into a blockchain for example
has only been submitted once.

In summary, a Nonce (in Cyptography) is something that is created, 
randomized that exists only once, and is used for a specific 
purpose.

// End of personal note.

So the Blockchain basically is a block is connected to its
previous block via the privious blocks Hash, and!

The previous Hash is included in the data that goes through the 
hash algorithim, meaning that it is linked.

If you modify any part of the chain then all the hashes following 
it change, and since the one block also contains the pervious hash 
in the data that runs through the algorithim for the current block
the hash for that block changes as well.

This SHA helps us make this Blockchain immutable.

So another note: So when a Block is changed in some way, the 
block becomes unverified (or unsigned) and the hash looses its
"0000" status, which means that you have to remine (or reverify) 
the transactions in that Block.

Due to the linking nature of the Blockchain, all the suceeding
blocks become unverified, meaning that all the blocks have to be
remined from the "break" in the chain.

//------

Distributed Blockchains.

So with a distrubuted Blockchains you have a multiple peers
on the network, that have a precise copy of the Blockchain.

These "peers" can be anyone with a computer.

So how do I know that one chain hasn't just modified the chain,
and remined all the blocks (giving it the 0000 signature)?

Well, When you have multiple peers using the exact same
blockchain, they should all have the exact same hash at the 
current block that they are on.

You can compare all of the Hashes, and when you see a peer 
with a different hash at the end, then you know that 
something went wrong / is fishy (lol).

// Adding tokens to the mix.

When you add transactions of tokens between people, and you add that 
to the way the Hashing algorithm works, and with multiple peers
working on verifiying and adding Blocks, the Blockchain becomes 
immutable.


// ----

Coinbase transaction

Coinbase stands for a person's balance or the base of his coins.

Basically in this, we're going back and verifying that "Nathan"
has 100 dollars and when he sends tokens to the person, that he
has those coins in the first place.

// ---------

Continuing with the Ethereum Documentation.

In the Ethereum universe, there is a single canonical computer
called the Ethereum Virtual Machine. (or the EVM). whose state
everyone on the Ethereum network agrees on. Everyone who
participates in the Ethereum network (every Ethereum node) keeps
a copy of the state of the computer.

Additionally, any participant can broadcast a request for this 
computer to perform arbitrary computation. Whenever such a 
request is broadcast, other participants on the network
verify, validiate and carry out ("execute") the computation.

This execution causes a state change in the EVM, which is 
committed and propagated throughout the entire network.

Requests for computation are called transaction requests; the 
record for all transactions and the EVM's present state gets 
stored on the Blockchain, which in turn is stored and aggreed 
upon by all nodes.

Cryptographic mechanisms ensure that once transactions are 
verified as valid and added to the blockchain, they can't be
tampered with later.

The same mechanisms also ensure that all transactions are signed 
and executed with appropriate "permissions" (No one should be able
to send digital assets from nathan's account, except for Nathan
himself.)

--- What is Ether? ---

The purpose of Ether, is to allow for a market for computation.

Such a market provides economic incentive for participents to 
verify and execute transaction requests and provide computational
resources to the network.

Any participant who broadcasts a transaction request must also
offer some amount of Ether to the network as a bounty.

This bounty will be awarded to whoever eventually does the work
of verifying the transaction, executing it, and commiting it to 
the blockchain, and broadcasting it to the network.

The amount of Ether paid corresponds to the time required to do 
the computation.These bounties also prevent malicious 
participents from intentionally clogging the network
by requesting the execution of infinite computation or other
resource-intensive scripts such as these participents must
pay for the computation time.

--- What are Smart Contracts? ---

In practice, participants don't write new code everytime they want 
to request computation on the EVM.

Rather application developers upload programs (Reusable snippets
of code) into EVM storage, and users make requests to execute
these code snippets with varying parameters. 

We call these programs uploaded to and executed by the network
smart contracts.

At a very basic level, you can think of a smart contract like 
a sort of vending machine: a script that when called with 
certian parameters, performs some actions or computation if 
certian conditions are satisfied.

For example, a simple vendor smart contract could create 
and assign ownership of a digital asset if the caller sends 
Ether to a specific recipient.

Any developer can create a smart contract and make it public 
to the network, using the blockchain as its data layer,
for a fee paid to the network.

Any user can then call the smart contract, execute the code,
again for a fee paid for the network.

Thus with Smart Contracts, developers can build and 
deploy arbitrarily complex user-facing applications
and services such as marketplaces, financial instraments,
games etc.

----- Terminology -----

Blockchain

- The sequence of all blocks that have been comitted to the 
Ethereum network in the history of the network.
- So named because each block contains a reference hash to the 
previous block, which helps us maintain an ordering over all
blocks (and thus over the precise history.)

ETH 

- The native Cryptocurrency of Ethereum.
- Users pay Ether to other users to have their code execution
requests fulfilled.

EVM

- The Ethereum Virtual Machine is the global virtual computer
whose very state every participent on the Eth network stores
and agrees upon.
- Any participent can request the execution of arbitrary code
on the EVM; code execution changes the state of the EVM.

Nodes

- Nodes are the real life machines which are storing the EVM state.
- Nodes communicate with each other to propagate information 
about the EVM state and new state changes.
- Any user can also request the execution of code by broadcasting 
a code execution request from a node.
- The Ethereum network itself is the aggregate of all Ethereum
nodes and their communications.

Accounts

- Accounts is where Ether is stored. 
- Users can initialize accounts, deposit ether into the accounts, 
and transfer ether from their accounts to other users.
- Accounts and account balances are stored in a big table in the EVM.
- They are a part of the overall EVM state.

Transactions 

- A "Transaction request" is the formal term for a request for code 
execution on the EVM, and a "Transaction" is a fulfilled trnascation
request to affect the aggred-upon EVM state, it must be validiated,
executed and "Committed to the network" by another node.
- Execution of any code causes a state change in the EVM; upon
commitment, this state change is broadcast to all nodes in the network.

Some examples of transactions:

- Send X ether from my account to Frank's account.
- Public some smart contract code into EVM memory.
- Execute the code of the smart contract at address X in the EVM,
with arguments y.

Blocks

- The volume of transactions are very hig, so transactions are 
committed in batches or blocks.
- Blocks generally contain dozens to hundreds of transactions.

Smart Contracts

- A reusable snippet of code (a program) which a developer 
publishes into EVM memory.
- Anyone can request that the smart contract code be executed
by making a transaction request.
- Because developers canwrite arbitrary executable applications
into the EVM (Games, marketplaces, financial instruments, etc) 
by publishing smart contracts, these are often called dApps
or Decentralized Applications.

End of Intro to Ethereum.

//-----------------------------------------------------------------

Intro to Ether.

A cryptocurrency is a medium of exchange secured by a Blockchain based ledger.

A medium of exchange is anything widely accepted as paymet for 
goods and services, and a ledger is a data store that keeps
track of transactions.

Blockchain tech allows users to make transactions on the ledger
without the reliance upon a trusted third party to maintain the 
ledger.

Ether is the currency used for many things on the Eth network. 
Fundamentally, it is the only acceptable form of payment for
transaction fees, and after the mege is also required in ordering
to validate and propose blocks on the Mainnet. 
Ether is also used as a primary form of colateral in the DeFi
lending markets, it is also used as a unit of account in NFT
marketplaces, as payment earned for performing services or selling
real-world goods, and more.

Ethereum allows developers to create dApps, which all share a pool
of computing power. This shared pool is finite, so Ethereum
needs a mechanism to determine who gets to use it. Otherwise 
a Dapp could accidentally or maliciously consume all network 
resources, which would block others from accessing it.

Ether supports a pricing mechansim for Ethereum's computing power. 
When users want to make a transaction, they must pay Ether to have
their transaction recognized on the Blockchain. These usage costs 
are called Gas fees, and the gas fee depends on the amount of computing 
power required to execute the transaction and the network wide 
demand for computing power at the time.

Therefore even if a malicious app submitted an Infinite loop, the
transaction would run out of Ether and terminate, allowing the 
network to return to normal.

Minting Ether ---

Minting is the process in which new ether gets created on the Ethereum
ledger. The underlying Ethereum protocol creates new Ether, and it is not
possible for a user to create Ether.

Ether is minted with a miner creates a new block on the Ethereum blockchain.
As an incentive to miners, the protocol grants a reward to each block,
incrementing the balance of an address set by the block's miner. 
The block reward has changed over time, and today it is 2 Ether per block.

Burning Ether

Ether burn occurs with every transaction on Ethereum, when users pay
for their transactions, their base gas fee gets destroyed by the protocol.
Depending on the network demand, some blocks burn more than they mint.

---- denominations of Ether ----

Since many transactions on Ethereum are small, Ether has several 
denominations which may be referenced for smaller amounts.

Wei and gwei

Wei is the smallest possible amount of Ether, and as a result
many technicial implementations (Such as the Ethereum Yellowpaper) 
will base all calculations in Wei.

Gwei short for giga-wei is often used to describe gas fees on Ethereum.

Wei 10 to the (-18th power) (Technical implementations).

Gwei 10 to the (-9) (Human readable gas fees).


----- Transferring Ether -----

Each transaction on Ethereum contains a value field, which specifies 
the amount of Ether to be transfered, denominated in Wei, to send from
the sender's address to the reciepent address.

When the recipient address is a smart contract, this transferred Ether 
may be used to pay for gas fees when the smart contract executes its code.

----- Querying Ether -----

Users can query the Ether balance of any account by inspecting the account's 
balance field, which shows Ether holdings denominated in Wei.

Etherscan is a popular tool to inspect address balances via a web-based
application. For example, this Ether scan page shows the balance 
of the Ethereum foundation.


-------- Introduction to Dapps -------

A decentralized application (dapp) is an application built on a decentralized 
network that combines a smart contract and a front end user interface.

On Ethereum smart contracts are accessible and transparent, like open APIs -
so your Dapp can even include a smart contract someone else has written.

-- Definition of a Dapp. -----

A dapp has its backend code running on a decentralized peer-to-peer network.
Contrast this with an app where it's backend code is running on centralized 
servers.

a Dapp can have frontend code and user interfaces written in any languages
(just like an app) to make calls to its backend. Furthermore, it's frontend
can get hosted on Decentralized storage such as IPFS.

- Decentralized - dapps opperate on Ethereum an open public decentralized
platform where no one person or group has control.

- Deterministic - dapps perform the same function irrespective of the environment
in which they got executed.

- Turing complete - Dapps can perform any action given the required resources.

- Isolated - dapps are executed in a virtual environment known as EVM so that 
if the smart contract has a bug, it won't hamper the normal functioning 
of the Blockchain network.

----- On smart contracts -----

To introduce dapps, we need to introduce smart contracts, a dapp's backend 
for lack of a better term.

Smart contracts is a code that lives on the Ether blockchain and runs 
exactly like it was programmed.

Once smart contracts are deployed on the network you cannot change them.
Dapps can be decentralized because they are controlled by the logic
written into the contract, not an individual or company.

This also means you need to design your smart contracts very carefully
and test them throughly.

----- Benefits of dapp development -----------


- Zero downtime: Once the smart contract is deployed and on the Blockchain, 
The network as a whole will always be able to serve clients looking to interacting
with the contract. Malicious actors, therefore cannot launch DDOS attacks
targeted to invididual dapps.

- Privacy: You don't need to provide your real-word identity to deploy or interact 
with a dapp.

- Resistance to censorship: No single entity on the network can block users
from submitting transactions, deploying Dapps, or reading data from the
blockchain.

- Complete data integrity: Data stored on the Blockchain is immutable and 
indesputible, thanks to cryptographic primitives. Malicious actors cannot 
forge transactions or other data that has already been made public.

- Trustless computation / verifiable behavior: Smart contracts can be 
analyzed and are gauaranteed to execute in predictible ways, without the
need to trust a central authority.
This is not in tune in traditional models; for example, when we 
use online banking systems, we must trust that financial institutions 
will not misuse our finanaical data, tamper with records or get hacked.

------ Drawbacks of Dapp Development ----------

 - Maintenance: dapps can be harder to maintain because the code and data
 published to the blockchain is harder to modify. Its hard for developers 
 to make updates to their dapps (or the underlying data stored by a dapp)
 once they are deployed - even if bugs or security risks are idendified
 in an older version.

 - Performance overhead: there is a huge performance overhead, and scaling
 is really hard. To achieve the level of security, integrity, transparency
 and reliability that Ethereum aspires to, every node runs and stores
 every transaction. On top of this. Proof-of-work takes time as well. 
 A back-of-the-envelop calculation puts the overhead at something like
 1,000,000x that of the computation currently.

 - Network congestion: When one dapp uses too many computational 
 resources, the entire network gets backed up. Currently the network
 can only process 10-15 transactions per second; if the transactions
 were being sent are faster than this, the pool of unconfirmed 
 transactions can quickly balloon.

 - User experience: It may be harder to engineer user-friendly 
 experiences because the average end-user might find it too dificult to
 to set up a tool stack necessaryt to interact with the blockchain in a 
 truely secure fashion.

 - Centralization:  User-friendly and developer friendly solutions built
 on top of the base layer of Ethereum might end up looking like centralized
 services anyway. For example, such services may store keys  and other 
 sensitive information on the server-sider, serve a frontend using a 
 centralized server, or run important business logic on a centralized 
 server before writing to the blockchain. Centralization eliminates any
 (if not all) of the advantages of Blockchain over the traditional model.

-- Web 2 vs Web3 ---

Web2 refers to the version of the internet most of us know today.
An internet dominated by companies that provide services in exchange for 
personal data. In Web3, in the context of Ethereum refers to decentralized
applications that run on the blockchain. These are apps that allow anyone
to participate without monetising their personal data.

-- Web3 benefits --

Many web3 developers have chosen to build dapps because of Ethereums
inherent decentralization:

- Anyone who is on the network has permission to use the service - or 
in other words, the permission isn't required.

- No one can block you or deny your access to the service.

- Payments are built in via the native token, Eth.

- Ethereum is a turing-complete, meaning you can pretty much program
everything.

Practical comparisions.

Web2 
- Twitter can sensor any account or tweet.
- Payment service may decide to not allow payments for certian types of work.
- Servers for gig-economy apps could go down and affect worker income.

Web3 
- Web3 tweets would be uncensorable because control is decentralized.
- Web3 payment apps require no personal data and can't prevent payments.
- Web3 servers can't go down - they use Ethereum, a decentralized network
of computers as their backend.

This dosen't mean that all services need to be turned into a dapp.
These examples are illustrative of the main difference between web2 and 
web3 services.

