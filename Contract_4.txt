Personal note:

This is my notes from this video tutorial from dApp university.

https://www.youtube.com/watch?v=ipwxYa-F1uY&t=44s

My goal with this is to learn the code, write notes down that I 
can reference later.

At the end of the tutorial, I will:

1. Write down the beginning code, and the end code.
2. I will write out two copies of the code.
    1. The unexplained code.
    2. The explained code, the goal is to get myself familiar on
    how to explain the code, how it works and the proper syntax and
    nomenclature.
3. I will go through the contract and explain how it works, the syntax
and the direct nomenclature of the syntax.

//----------------------------------------------------------------

Beginning contract.

// SPDX-License-Identifier: MIT

pragma solidity 0.5.1;

contract myContract {
    mapping(address => uint256) public balances;
    // mapping, user address which is key, and the value is the 
    // balance of the account, public visibility and the mapping 
    // variable name is balances.
    address payable wallet;

    event Purchase(
        address _buyer,
        uint256 _amount
    );

    constructor(address payable _wallet) {
        wallet = _wallet;
    }

    fallback() external payable {
        buyToken();
    }


    function buyToken() public payable {
        // Buy a token.
        balances[msg.sender] += 1;
        wallet.transfer(msg.value);
        // Send ether to the wallet.
        emit Purchase(msg.sender, 1);


    }
}


// Start of the tutorial.

In this tutorial we're going to go through how to use multiple 
smart contracts in the Solidity programming language.

We're going to write two seperate Smart Contracts, one that will
talk to the other and also show you how to understand parent-child.
relationships with Smart Contracts.

(Basically we'll talk about inheritance.).

We're going to keep the scenario where we're going to buy the token.

Instead of keeping track of the balance inside of this Smart Contract,
we're going to spilt the contract into two.

We'll move the balance code into a Token contract, and the buyToken

This is again, going to be a super basic example, it won't be an 
ERC-20 compatible token, but it will be a functional example.

We'll explore how two contracts call one another at a very simple 
example.

Starting with the Token contract, we'll start with defining the
contract.

contract ERC20Token.

We'll declare a state variable 'name', and we'll give it the
public visibility. 

string public name;

We're going to transfer the balances mapping.

mapping(address => uint256) public balances;

We're going to take the balance increment function, and put it into
it's own function.

We're also going to write ++ instead of += 1.

We took out the purchase event to simplify the code.

Inside of the ERC20 contract, we want to mint tokens.

We want to call the ERC20 contract in the buyToken() function.

Since both contracts are in the same file, they know that each other 
exists.

We can be basically explicit and tell this contract if you want to mint
tokens in this contract.

In order to do that there's a few things we need.

We need to know the address of this contract which is deployed because
both contracts will have seperate addresses since they can only be 
deployed seperately.

myContract needs to know about the ERC20Token contract's address.

Then we'll basically reference the smart contract with the address.

And we'll kindof get an instance of it and then we'll call the mint
function on it.

This is a two step process.

1. We need ERC20Token's address so that myContract can reference it.
2. Then we need to instansiate myContract.
3. We call the mint() function.

First we'll get access to this Token address, we'll say address token
in the parameters of the constructor function.

We'll also give it the public visibility.

constructor (address payable _wallet, address _token) public {
    wallet = _wallet;
    token = _token;
}
    
So with that, we have the address, we need to get an instance of it.

So we're instanciating the contract with calling the
ERC20Token(); call inside of the buyToken() function call.

We do that by passing in the Token address that we've kept track of
here.

Since ^0.5 requires explicitness, we'll add in 

ERC20Token(address(token));

Basically with instantiating the ERC20Token, in this case, its 
deployed, and calling this address, we'll use this token to call the
mint function. 

All of this we can assign to a variable, and with Solidity we have to
specifiy the data type.

The data type will be ERC20Token, and this is a local variable not 
a state (global) variable, so we're going to prepend it with an
underscore.

ERC20Token _token = ERC20Token(address(token));

// Heres a breakdown of the syntax, ERC20Token is the data type.
_token is the variable name, and the ERC20Token(address(token) is the
location of that token variable??????????????????????????



Now we can mint the token like this.

_token.mint();

Now we can call this by token function from this smart contract, and
you'll call the mint() funciton from the ERC20Token contract.

// Personal note:

This point in the tutorial, I ran into an error, that I'm not sure how
to deal with at this point in my Education, so I'm passing over it at
this point, and I'll try to revisit it at some point.

// Sooo, in the tutorial, he uses the buyToken() function, and the
transaction goes through, only the issue is that since I cannot
run that function due to the error I keep getting, I can't fully 
experience this myself.

Keep in mind, we deployed two contracts in remix with this file, 

1. the ERC20Token contract.
    has the:
        mint() function,
        name state variable,
        and also has the balances mapping.
2. the myContract.
    has the:
        buyToken() function.

In the tutorial, he uses the buyToken, the transaction goes through
but the balance of that specific address does not go up.

However, when uses the mint() function on the ERC20Token, the
balance does go up.


Basically he goes on to say that the msg.sender function can sometimes
mess you up when you call a function from SC1 in SC2.

Earlier when you call the mint() function directly, the balance goes
up.

This is because msg.sender in this case is the address of contract that
called the function, NOT who sent it.

So we can get the address of the contract/person who sent the initial
tranaction with the tx.origin function.

that will actually mint functions for whoever initiates the transaction

So if we call Mint function from the ERC20Token contract, it'll
increment the balance, and if we call it from the myContract it'll 
also increment the balance of the person/contract who called the
buyToken() function.

So the msg.sender function can be a real gotcha when dealing with
multiple smart contracts interacting with each other.

// So now 