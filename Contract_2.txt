Introduction

This is the second smart contract for this tutorial:
https://www.youtube.com/watch?v=ipwxYa-F1uY&t=44s

----------------------------------------------------------

The first thing we're going to do in this video is that we're
going to update the contract code that we wrote before to to the latest
version of solidity.

Solidity 0.5.1.

Okay so we can read the error in remix IDE, and it gives us two
type errors.

TypeError: data location must be "memory" for return parameter in function but none was given.

The error is noted at line 19 and line 25.

All we have to do to fix this error is to add memory to the return parameter.

Using the Remix IDE, we compiled the contract and the error is fixed.

Now we're going to get going on the main focus of this video, we're going to
be covering the basic data types and data structures in Solidity.

First thing we're going to go over is the different ways we can go over
state variables.

At the top of the contract we have the state variable 'string value'
that we declared and set it and retrieved the values.

Solidity has a shortcut where you don't even need the get function.

You can basically read it for free.

We're going to add the public keyword on the end of the state variable.

The public keyword is declaring the visibility of the state variable.

After compiling the code, and deploying it onto a blockchain we can see it on the remix
IDE that you can read the code for free.

We can also just add a default value, so let's look at this.

We're going to delete the constructor function because we don't need it.

We're also going to define the string value to 'myValue' inline on the state variable.

We can also set the string value to constant to make the variable immutable.

We'll define the variable as a constant inline on the state variable declaration.

Now let's look at some different data types in Solidity.

We updated the string to stringValue.

Alright let's explore some different types, so we can have a Boolean value in Solidity.

Booleans:

Integers can be signed and unsigned.

The difference between a int (Integer), and a uint (Unsigned Integer).

Int can be signed.

Uint can be unsigned.

What does that mean? Well, a int can be signed, in other words, can be a negative
number.

An int can be -1. The negative sign is the "sign" in the signed or unsigned integer.



string public stringValue = "myString";
    bool public myBool = true;
    int public myInt = -1;
    uint8 public myUint8 = 8;
    uint256 public myUint256 = 99999;

So that is some of the basic data types.

Enum - Enum means enumerated list and it will allow us to keep
track of a set list of things in our contract. We'll take a look on what this means.

Added enum State { Waiting, Ready, Active}. 

This allows us to keep a list of these three states of the contract inside the smart
contract.

We'll be able to reference this to check the state of the contract.

This allows us to set or reference the state of the contract in the code copied below.

// ---------------------------------------------------------------------
Raw code:

contract myContract {
    enum State{ Waiting, Ready, Active } 
    State public State; 


    constructor() public {
        state = State.Waiting; 

    }
    
    function activate() public {
        state = State.Active; 

    }

    function isActive() public view returns(bool) {
        return state == State.Active; 
    } 
}

//------------------------------------------------------------------------------------------------------------

Code explained:

contract myContract {
    enum State{ Waiting, Ready, Active }
    
     // Enum list of States of the smart contract.
    
    State public State; 
    
    // We'll be able to access this publicly with the getter.


    constructor() public { 
        
        // When constructing the contract, we set the default state to Waiting below.
        
        state = State.Waiting; 
        
        // Sets the default State to Waiting.

    }
    
    function activate() public { 
        
        // Function to activate the smart contract.

        state = State.Active; 
        
        // Updates the State of the Smart Contract when this function is called.

    }

    function isActive() public view returns(bool) {
        
        function declaration, public visibility, (visible to anyone on the Blockchain.) ZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZ
        
        return state == State.Active; 
        


        // Note, since this list is enumerated, then this will return an index value of the State enum list.
    } 
    

// So it will return 0 if the contract is Waiting.
}

Alright so now, we're going to explore structs.

Structs is a way in Solidity to define our own data structures.

This allows us to model our own sort of arbitrary data.

We're going to have a Person Struct.

This Struct(Person) is going to have several attributes such as.
First name, Last Name both strings. 

We can put these structs inside of Mappings and Arrays.

In this, We've declared the data type Person inside the smart contract with a struct.
thats going to have a first name and a last name.

So lets create a function that can instantiate a new Person. Create a new one and 
actually keep track of a bunch of these person structs inside of a people array.

First let's create a Person[] array, we'll call it people, and we'll make it public so you can
read it outside of the Smart Contract.

It's a data type of this person.

Person is a struct, and the Person[] Array contains different instances of the Person struct.

It's stored with the 'people' State Variable.

We're going to create a function for adding a person to the Person[] array.

We're going to add it with a function, with the parameters for the instance for that person.

So we'll pass into the function, the first name and last name of that person.

Then we'll add that person into the Array with the people.push() method.

This adds the person onto the end of the array.

We'll declare the struct data type Person, and the first and last name of that person to add that person to the people array.

String declares the data type.


The thing is with the arrays in Solidity is that you can't read them.
So we'll create a function for displaying the count of the array, and since its indexed, we can read the contents
of that instantiation.

We'll add uint256 public peopleCount, and inside the addPerson function.
We'll increase the peopleCount by an increment of one.























