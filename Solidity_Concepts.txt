

Nathan's note:

This is going to be my notes / transcripts of learning the concepts and the language of Solidity.

Mostly this learning style is that I watch a video, and type the transcript out to fully learn the concepts instead of just watching the video.

This is going to be notes focused on relevant learning, I'm mostly going off of dApp universities videos, and if I don't understand a concept.
I'll look to other resources to learn that concept more in depth, and then I'll use the Feynman Technique to learn it further for my brain.

//--------------------------------------------------------------------------------------------------------------------------------------------

Table of Contents:

- Data Location in Solidity - Line 23.

- Fallback Function - line 181.

// ----------------------------------------------------------------------------------------------------------------------------------------------


https://blockheroes.dev/data-location-in-solidity/

Data Location in Solidity.

There are three "Locations" in which the EVM stores variables: 
	- STORAGE, MEMORY AND CALLDATA.

 You might have seen them in the declaration of some variables, but, 
 you've probably noticed that they are usually missing.

This doesn't mean that some variables don't have a location, 
we know that every declared variables is stored somewhere.

Also the data location rules differ according to the variables type and scope.

	- Type.
		○ Reference type: array (including strings or bytes) mapping, structures.
		○ Value type: all the others, for example, uint or bool.
	- Scope.
		○ Local variable. 
			§ Declared inside a function.
		○ Global variable.
			§ AKA state variables, declared outside of all functions.

We'll go through the following concepts of data location in Solidity.
	- Definitions and Usage.
	- Helpful facts.
	- Assignment Rules.

This information is up to date post Soliditiy ^0.8.7.

Definitions and Usage:
	
	Each Data location in Solidity has a different purpose and we should use them cautiously. 
	Keep in mind that, in some situations, Solidity strictly enforces a default location.
	
Storage 
	- When placed in storage, a variable is written on the Blockchain, Everything that is on the chain, stays there. 
	- Every contract has its own storage, so these variables are persistent.
	- Therefore you can access storage variables at all times. 
	- You can modify their value but their location is permanent, Every change is registered on the Blockchain.

Memory
	- Variables stored in memory are declared inside a function. They are temporary and their 'lifetime' 
	- is dependent on the runtime of the function they correspond to.
	- They are only accessible inside that method.
	- Their purpose is to assist calculations.

Calldata
	- Calldata is a temporary data location in Solidity. It acts like memory, in terms of its dependence 
	- on the function's execution.
	- The variables stored in Calldata are only available inside the function they are declared in.
	- On top of that, Calldata variables are not modifiable. 
	- This means that they cannot change their value.

Helpful facts.

	- There are some useful facts about data location in Solidity that might help you along the way. 
	- It is best to know them to avoid silly mistakes.

Gas.
	- Storage is the most expensive data location you can use.
	- Then there's memory which is between the two.
	- And the cheapest being Calldata.
	- Modifying storage is one of the most expensive operations you can do on Ethereum. To be memory efficient, 
	- try to minimize the number of times you alter state (global) variables.
Must do.
	- State (Global) variables always stay in storage and you cannot explicitly override that.
	- Function parameters (Including the return parameters) must be in memory or calldata.
// Prior to version ^0.6.9 data location for reference type arguments was limited to 
// calldata in external functions, memory in public functions and either memory or storage in internal and private functions.
// Now memory and calldata are allowed in all functions regardless of visibility.
	- You cannot override the location of local variables of value type. 
	- You get a parser error. By default, they sit in memory.
	- Since ^0.5.1, you must specify the location of Local variables of reference type. 
	- If you don't you will get a type error.

Assignment Rules.
	- When assigning a storage variable the value of memory (Or calldata) one, it will create a copy. The other way around is true as well.
	- Assignments between value types from the same data location (E.g. storage to storage) will make a copy.
	- For reference types, when assigning from one memory variable to another memory variable, it will create a reference. 
	- They will point to the same data location. So if you modify one of them, it will reflect in both.
	- Assigning from storage to local storage variables will also result in a reference.
-------------------------------------------------------------------------------------------------

Memory VS Storage in Solidity -  Data Location Tutorial


Memory vs. Storage.

Storage:
	- Global. 
	- Meaning that the are available globally - In other words, are available in the entire contract,
	- Inside and outside of the functions.
	- They're also stored permanently - meaning that even though it doesn't matter if you're sending a transaction or executing a function or not doing anything at all, 
	- The Ethereum Network will save your variable forever until the contract is removed.
	- State Variables (or global variables)
Memory
	- Local.
	- Temporary.
	- Local Variables.
	- AKA variables in function bodies.
	- After the function is performed, the variables assigned inside of the function will be removed from memory, making them temporary.
	- The same rule applies to arguments, they are temporarily stored in memory under 'Memory', and will be removed from memory once the
	- function execution is completed.
Now we're going to look at a smart contract in this video, and see how big of a mistake you can make when you don't understand the difference
between storage and memory.

pragma solidity 0.5.2;

contract MemoryAndStorage {
	
	mapping(uint => User) users;

	struct User{
		uint id;
		uint balance;
	}

	function addUser(uint, id, uint balance) public {
		users[id] = User(id, balance);
	}

	function updateBalance(uint, id, uint balance) public {
		User memory user = users[id];
		user.balance = balance;
		}

	function getBalance(uint id) view public returns (uint) {
		return users[id].balance;
	}
}

Alright, so after looking at this contract, the updateBalance function is what we're going to look at.

The issue is that when we use the use the updateBalance function, the new data will be stored to temporary memory, and not actually 
writting the new value to the mapping (storage).

User memory user = users[id];
user.balance = balance;

User storage user = users[id];
user.balance = balance;

One way to solve this problem is just to change the updateBalance's data location from memory to storage.

Another way to solve this issue is to modify the mapping directly.

user[id].balance = balance;

Another way we can fix this is:

User memory user = users[id];
user.balance = balance;
users[id] = user;

This is bad because the code isn't very clean and it copies back and forth unnecessarily.

//-----------------------------------------------------------------------------------------------


https://www.youtube.com/watch?v=3FY9FkJKSSI


Fallback Functions:

Let's talk Fallback Functions.

The function cannot be named, it cannot take any inputs, and it cannot return and outputs.

They must be declared with the external function modifier.

This function will be called in two situations.

1. When you call a function that does not exist.
2. When you send Ether to this contract by 'send', 'transfer' or 'call'.

In order for this contract to recieve Ether the fallback function must have the payable modifier declared.

You can write the contractFunction inside of the fallback function, but it is not recommended.


myContract{

	function() external payable { // the contract function is wrapped in the fallback function.
		contractFunction()
	}
}

The reason is that when you send Ether by 'Send' or 'Transfer' it forwards 2300 gas to this fallback function.
Which is enough gas to Emit a log, but not enough gas to write to Storage or call another contract.


contract Fallback{
	event log(uint gas);

	function() external payable { 
		// Send / Transfer (forwards 2300 gas to this fallback function)
		emit Log(gasLeft())
	}
}

In order to prove that it only forwards 2300 gas, we're going to use a special function here called gasLeft, that returns 
the remaining Gas.

We'll also update our log event to return the amount of Gas left.

We'll also create a helper function that returns the the amount of Ether stored in this contract.


contract Fallback{
	event log(uint gas);

	function() external payable { 
		// Send / Transfer (forwards 2300 gas to this fallback function)
		emit log(gasLeft())
	}

	function getBalance() public view returns (uint) {
		return address(this).balance;
	}
}

contract SendToFallback {

	// In the inputs for the Transfer function below, we'll pass in the address of the Fallback contract above.
	function transferToFallback(address payable _to ) public payable {
		_to.transfer(msg.value);
	}

	function callFallback(address payable _to) public payable {
		// We'll send Ether using the call method and make sure it was able to send the Ether.
		(bool sent,) = _to.call.value(msg.value)("");
		require(sent, "Failed to send Ether.");


	}

}



We're also going to create a contract that will send Ether to the contract above, which will trigger the fallback function.

We're going to send Ether with the Transfer method.

After we deploy these two contracts here we're going to pass in the address of the fallback contract above.

Transfer forwards 2300 Ether and later whne we actually call this function here with the Emit Log(gasLeft()); we'll be able
to see how much is left.

Sending the Ether fowards all the gas to the fallback function and in that case gas theft can be greater than 2300.

And to demonstrate this we're going create a function thats going the fallback contract above using the call method, and we'll name this 
function callFallback.



//-------------------------------------------------------------------------------------------------------------------------


Summary:


Fallback Function:
- Recieves 2300 Gas from transfer and send Methods.
- But it can recieve more gas when it is invoked by the call method.
- The Call method can forward all of the gas to the fallback function.
-- Which means that you can write code like a regular function to execute inside the fallback function
-- But it is not recommended to write much code inside the fallback function because transfer and send can fail.
-- Or it can fail if it uses too much gas.
-- Which means you won't be able to send Ether to the contract using the send or transfer method.

// -----------------------------------------------------------------------------------------------------------------------------------

Fallback Functions Documentation

https://docs.soliditylang.org/en/latest/contracts.html?highlight=fallback%20function#fallback-function

A contract can have a most one fallback function, 
- declared using the fallback() external [payable] or 
- fallback(bytes calldata _input) external [payable] returns (bytes memory _output) 


- Both without the function keyword.
- This function must have the External visibility.
- A fallback function can be:
	- Virtual.
	- Can override.
	- Have Modifiers.

The fallback function is executed on a call to the contract if none of the other functions match the given function signature, 
- or f no data was supplied at all and there is not receive Ether function.
- The fallback function always recieves data but in order to also recieve Ether it must be marked 'payable'.

--

If the version with the parameters is used, _input will contain the full data sent to the contract (equal to msg.data) and can return in
_output. 

The returning data will not be ABI encoded, instead it will be returned without modifications (not even padding).

In the worst case, if a payable fallback function is also used in place of a recieve funtion, it can only rely on 2300 gas being available. 
(See above tutorial.)

Like any function, the fallback function can execute complex operations as long as there is enough gas passed into it.

//-------------------------------------------------------------------

Solidity address

it comes in two flavors, which are largely identical.

address holds a 20 byte size, (size of an Ethereum adress).

address payable, is largely the same but with the additional members transfer and send.

The idea behind the distinction, is that payable address is an address you can send Ether to.

//------------------------------------------------------------------------

https://www.natchineth.com/post/solidity-function-specification-and-modifiers/

Solidity function visibility 
Specifications and Built in Modifiers.

What's the difference between Solidity Function Visibility (Public, External, Private and Internal)?
What should you use one over the other?
How do you know when to use Solidity Modifiers(pure, view)?

Solidity functions are usually of the following form, where it specifies a function visibility and a modifier attributed to a certian function.

This blog post goes into detailed function visibility specifiers(Public, External, Private, Internal) and a few select modifiers (pure, view)
that often cause confusion between developers.

// ----------------------------------------------------------------------------------------

Public Visibility.

In Solidity, the Public keyword is used for functions where they can be called by any external account and any internal/external contract on the 
Blockchain.

This means that public functions are used in cases where a function is expected to provide information to anyone who calls it.

A good example where a public function may be useful is in cases where variables are being accessed or overall state changes.

By looking at the ERC-20.sol token implementation, there are a variety of functions below that are public. An example of public functions used in the 
standard are below:

function transfer(addres recipient, uint256 amount) public virtual override returns (bool) {
	_transfer(_msgSender(), recipient, amount);
	return true;
}

The transfer()function can be called by anyone with an external address(one in a wallet) and any contract to transfer token funds from the sender
to a certain recipient.

The public modifier on this function ensures that there are no access control restrictions on who can call this function.

//----------------------------------------------------------------------------------------------

External functions
