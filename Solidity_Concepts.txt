
https://blockheroes.dev/data-location-in-solidity/

Data Location in Solidity.

There are three "Locations" in which the EVM stores variables: 
	- STORAGE, MEMORY AND CALLDATA.

 You might have seen them in the declaration of some variables, but, 
 you've probably noticed that they are usually missing.

This doesn't mean that some variables don't have a location, 
we know that every declared variables is stored somewhere.

Also the data location rules differ according to the variables type and scope.

	- Type.
		○ Reference type: array (including strings or bytes) mapping, structures.
		○ Value type: all the others, for example, uint or bool.
	- Scope.
		○ Local variable. 
			§ Declared inside a function.
		○ Global variable.
			§ AKA state variables, declared outside of all functions.

We'll go through the following concepts of data location in Solidity.
	- Definitions and Usage.
	- Helpful facts.
	- Assignment Rules.

This information is up to date post Soliditiy ^0.8.7.

Definitions and Usage:
	
	Each Data location in Solidity has a different purpose and we should use them cautiously. 
	Keep in mind that, in some situations, Solidity strictly enforces a default location.
	
Storage 
	- When placed in storage, a variable is written on the Blockchain, Everything that is on the chain, stays there. 
	- Every contract has its own storage, so these variables are persistent.
	- Therefore you can access storage variables at all times. 
	- You can modify their value but their location is permanent, Every change is registered on the Blockchain.

Memory
	- Variables stored in memory are declared inside a function. They are temporary and their 'lifetime' 
	- is dependent on the runtime of the function they correspond to.
	- They are only accessible inside that method.
	- Their purpose is to assist calculations.

Calldata
	- Calldata is a temporary data location in Solidity. It acts like memory, in terms of its dependence 
	- on the function's execution.
	- The variables stored in Calldata are only available inside the function they are declared in.
	- On top of that, Calldata variables are not modifiable. 
	- This means that they cannot change their value.

Helpful facts.

	- There are some useful facts about data location in Solidity that might help you along the way. 
	- It is best to know them to avoid silly mistakes.

Gas.
	- Storage is the most expensive data location you can use.
	- Then there's memory which is between the two.
	- And the cheapest being Calldata.
	- Modifying storage is one of the most expensive operations you can do on Ethereum. To be memory efficient, 
	- try to minimize the number of times you alter state (global) variables.
Must do.
	- State (Global) variables always stay in storage and you cannot explicitly override that.
	- Function parameters (Including the return parameters) must be in memory or calldata.
// Prior to version ^0.6.9 data location for reference type arguments was limited to 
// calldata in external functions, memory in public functions and either memory or storage in internal and private functions.
// Now memory and calldata are allowed in all functions regardless of visibility.
	- You cannot override the location of local variables of value type. 
	- You get a parser error. By default, they sit in memory.
	- Since ^0.5.1, you must specify the location of Local variables of reference type. 
	- If you don't you will get a type error.

Assignment Rules.
	- When assigning a storage variable the value of memory (Or calldata) one, it will create a copy. The other way around is true as well.
	- Assignments between value types from the same data location (E.g. storage to storage) will make a copy.
	- For reference types, when assigning from one memory variable to another memory variable, it will create a reference. 
	- They will point to the same data location. So if you modify one of them, it will reflect in both.
	- Assigning from storage to local storage variables will also result in a reference.
-------------------------------------------------------------------------------------------------

Memory VS Storage in Solidity -  Data Location Tutorial


Memory vs. Storage.

Storage:
	- Global. 
	- Meaning that the are available globally - In other words, are available in the entire contract,
	- Inside and outside of the functions.
	- They're also stored permanently - meaning that even though it doesn't matter if you're sending a transaction or executing a function or not doing anything at all, 
	- The Ethereum Network will save your variable forever until the contract is removed.
	- State Variables (or global variables)
Memory
	- Local.
	- Temporary.
	- Local Variables.
	- AKA variables in function bodies.
	- After the function is performed, the variables assigned inside of the function will be removed from memory, making them temporary.
	- The same rule applies to arguments, they are temporarily stored in memory under 'Memory', and will be removed from memory once the
	- function execution is completed.
Now we're going to look at a smart contract in this video, and see how big of a mistake you can make when you don't understand the difference
between storage and memory.

pragma solidity 0.5.2;

contract MemoryAndStorage {
	
	mapping(uint => User) users;

	struct User{
		uint id;
		uint balance;
	}

	function addUser(uint, id, uint balance) public {
		users[id] = User(id, balance);
	}

	function updateBalance(uint, id, uint balance) public {
		User memory user = users[id];
		user.balance = balance;
		}

	function getBalance(uint id) view public returns (uint) {
		return users[id].balance;
	}
}

Alright, so after looking at this contract, the updateBalance function is what we're going to look at.

The issue is that when we use the use the updateBalance function, the new data will be stored to temporary memory, and not actually 
writting the new value to the mapping (storage).

User memory user = users[id];
user.balance = balance;

User storage user = users[id];
user.balance = balance;

One way to solve this problem is just to change the updateBalance's data location from memory to storage.

Another way to solve this issue is to modify the mapping directly.

user[id].balance = balance;

Another way we can fix this is:

User memory user = users[id];
user.balance = balance;
users[id] = user;

This is bad because the code isn't very clean and it copies back and forth unnecessarily.

